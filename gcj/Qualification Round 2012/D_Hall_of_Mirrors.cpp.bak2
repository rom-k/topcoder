#include <stdio.h>
#include <time.h>
#include <vector>
#include <list>
#include <set>
#include <string>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <sstream>
#include <queue>
#include <map>
#include <iomanip>
#include <cmath>
#include <stack>
#include <numeric>
#include <iterator>
#include <cstdio>
#include <cstdlib>
#include <climits>
#include <cfloat>
#include <utility>
#include <memory>
#include <functional>
#include <complex>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef vector<LL> VL;

#define FORE(it, c, T) for(T::iterator it = c.begin(); it != c.end(); it++)
#define FORI(i, n) for(int i = 0; i < (n); i++)
#define FORIS(i, s, n) for(int i = (s); i < (n); i++)
#define CLEAR(a) memset(a, 0, sizeof(a))
#define SORT(a) sort(a.begin(), a.end())
#define REVERSE(a) reverse(a.begin(), a.end())
#define PB(n) push_back(n)
#define SZ(a) int((a).size())
#define IPOW(a,b) ((long long) pow((double)(a),(double)(b)))
#define PI M_PI
#define EPS 1e-13
#define INF 0x7f7f7f7f

#define DEBUG 1
#define DBG(a) if (DEBUG) cout <<"DEBUG::: " <<a <<endl;
#define DBG2(a, b) if (DEBUG) cout <<"DEBUG::: " <<a <<"=" <<b <<endl;

//double xme = 0.;
//double yme = 0.;

//inline double dist_of(double x1, double y1, double x2, double y2) {
//    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
//}
//
//inline double dist_of(double x1, double y1) {
//    return dist_of(x1, y1, xme, yme);
//}
//
//inline double angle_of(double x1, double y1, double x2, double y2) {
//    return atan2(y1 - y2, x1 - x2);
//}
//
//inline double angle_of(double x1, double y1) {
//    return angle_of(x1, y1, xme, yme);
//}

//struct _point {
//    double x;
//    double y;
//    double angle;
//    _point (double x0, double y0, double angle0) {
//        x = x0; y = y0; angle = angle0;
//    }
//    inline bool operator < (const _point a) const {
//        return angle < a.angle;
//    }
//};

struct _edge {
    double x1;
    double y1;
    double x2;
    double y2;
    _edge (double x10, double y10, double x20, double y20) {
        x1 = x10; y1 = y10; x2 = x20; y2 = y20;
    }
    inline bool parallel (const _edge a) const {
        return (x2-x1)*(a.x2-a.x1) + (y2-y1)*(a.y2-a.y1) > 0;
    }
};

void get_around (int H, int W, string blocks[], _edge e0, vector<_edge> edges) {
//                int a = 1;
//                while (y+a < W and blocks[y+a][x] == '#' and blocks[y+a][x+1]) {
//                    e.y1++; a++;
//                }
    
    _edge e = _edge(e0.x1, e0.y1, e0.x2, e0.y2);
    double x0 = e.x1;
    double y0 = e.y1;
//    double x = e0.x2;
//    double y = e0.y2;
    double dx = e.x2 - e.x1;
    double dy = e.y2 - e.y1;
    
//    while (x != x0 and y != y0) {
    while (e.x2 != x0 or e.y2 != y0) {
        double ddx = -dy;
        double ddy = dx;
        
        if (e.x2 < 0 or W <= e.x2 or
            e.y2 < 0 or H <= e.y2) {
            cout <<"ERROR" <<endl; return;
        }
        
        if (blocks[(int)(e.x2+dx)][(int)(e.y2+dy)] == '#' and
            blocks[(int)(e.x2+dx+ddx)][(int)(e.y2+dy+ddy)] != '#')
        {
            e.x2 += dx; e.y2 += dy;
        }
        else {
            edges.PB(e);
            
            dx = ddx; dy = ddy;
            if (blocks[(int)(e.x2)][(int)(e.y2)] == '#' and
                blocks[(int)(e.x2+dx)][(int)(e.y2+dy)] != '#')
            {
                dx *= -1; dy *= -1;
            }
            e.x1 = e.x2; e.y1 = e.y2;
            e.x2 += dx; e.y2 += dy;
        }
    }
    
    //fix first edge's start point
    if (e.parallel(e0)) {
        FORI(i, SZ(edges)) {
            if (edges[i].x1 == e0.x1 and
                edges[i].y1 == e0.y1 and
                edges[i].parallel(e0))
            {
                edges[i].x1 = e.x1;
                edges[i].y1 = e.y1;
            }
        }
    }
};

int main() {
    int T;
    cin >>T;
    cin.ignore();
    
    for(int t=1; t<=T; t++) {
        
        //input
        int H, W, D;
        cin >>H >>W >>D;
        string blocks[H];
        FORI(i, H) cin >>blocks[i];
        
        //initialize
        double xme, yme;
        vector<_edge> edges;
        FORI(y, H) FORI(x, W) {
            if (blocks[y][x] == 'X') {
                xme = x + 0.5;
                yme = y + 0.5;
            }
            
            if (x == W-1) continue;
            if (y == H-1) continue;
            
            //TODO: edges‚ÉŠÜ‚Ü‚ê‚Ä‚½‚çcontinue
            _edge e(x, y, 0, 0);
            if (blocks[y][x] == '#' and blocks[y][x+1] != '#') {
                e.x2 = x; e.y2 = y-1;
//                int a = 1;
//                while (y+a < W and blocks[y+a][x] == '#' and blocks[y+a][x+1]) {
//                    e.y1++; a++;
//                }
                get_around(H, W, blocks, e, edges);
            }
//            if (blocks[y][x+1] == '#' and blocks[y+1][x+1] != '#') {
//                e.x2 = x+1; e.y2 = y;
//                int a = 1;
//                while (x-a >= 0 and blocks[y][x-a] == '#' and blocks[y][x-a]) {
//                    e.x1--; a++;
//                }
//            }
//            if (blocks[y+1][x+1] == '#' and blocks[y+1][x] != '#') {
//                e.x2 = x; e.y2 = y+1;
//                int a = 1;
//                while (y-a >= 0 and blocks[y-a][x] == '#' and blocks[y-a][x+1]) {
//                    e.y1--; a++;
//                }
//            }
//            if (blocks[y+1][x] == '#' and blocks[y][x] != '#') {
//                e.x2 = x-1; e.y2 = y;
//                int a = 1;
//                while (x+a < H and blocks[y][x+a] == '#' and blocks[y][x+a]) {
//                    e.x1++; a++;
//                }
//            }
            
            
        }
        
//        //start loop
//        set<_point>::iterator it = corners.begin();
//        while (it != corners.end()) {
//            
//        }
        
        int ret = 0;
        cout <<"Case #" <<t <<": " <<ret <<endl;
    }
    
    return 0;
}
