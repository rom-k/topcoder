#include <stdio.h>
#include <time.h>
#include <vector>
#include <list>
#include <set>
#include <string>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <sstream>
#include <queue>
#include <map>
#include <iomanip>
#include <cmath>
#include <stack>
#include <numeric>
#include <iterator>
#include <cstdio>
#include <cstdlib>
#include <climits>
#include <cfloat>
#include <utility>
#include <memory>
#include <functional>
#include <complex>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef vector<LL> VL;

#define FORE(it, c, T) for(T::iterator it = c.begin(); it != c.end(); it++)
#define FORI(i, n) for(int i = 0; i < (n); i++)
#define FORIS(i, s, n) for(int i = (s); i < (n); i++)
#define CLEAR(a) memset(a, 0, sizeof(a))
#define SORT(a) sort(a.begin(), a.end())
#define REVERSE(a) reverse(a.begin(), a.end())
#define PB(n) push_back(n)
#define SZ(a) int((a).size())
#define IPOW(a,b) ((long long) pow((double)(a),(double)(b)))
#define PI M_PI
#define EPS 1e-13
#define INF 0x7f7f7f7f

#define DEBUG 1
#define DBG(a) if (DEBUG) cout <<"DEBUG::: " <<a <<endl;
#define DBG2(a, b) if (DEBUG) cout <<"DEBUG::: " <<a <<"=" <<b <<endl;
#define DBG3(a, b, c) if (DEBUG) cout <<"DEBUG::: " <<a <<":" <<b <<":" <<c <<endl;

/*
 * _edge struct
 */
struct _edge {
    double x0, y0;
    double x1, y1;
    double x2, y2;
    bool invert;
    
    _edge (double x00, double y00,
           double x10, double y10,
           double x20, double y20,
           bool invert0)
    {
        x0 = x00; y0 = y00;
        x1 = x10; y1 = y10;
        x2 = x20; y2 = y20;
        invert = invert0;
    }
    _edge (double x00, double y00,
           double x10, double y10,
           double x20, double y20)
    {
        _edge(x00, y00, x10, y10, x20, y20, false);
    }
    _edge (double x10, double y10,
           double x20, double y20)
    {
        _edge(0, 0, x10, y10, x20, y20, false);
    }
    
    inline bool operator < (const _edge a) const {
        return atan2(y1-y0,x1-x0) < atan2(a.y1-y0,a.x1-x0);
    }
    
    bool parallel (_edge a) {
        return (x2-x1)*(a.x2-a.x1) + (y2-y1)*(a.y2-a.y1) > 0;
    }
    bool includes (double x, const double y) {
        if (x == x1 and y == y1) return true;
        if (x == x2 and y == y2) return true;
        double inprod = (x1-x)*(x2-x)+(y1-y)*(y2-y);
        return inprod <= -1+EPS or 1-EPS <= inprod;
    }
    bool includes (_edge a) {
        return parallel(a) and includes(a.x1, a.y1);
    }
};

/*
 * _edge_set struct
 */
struct _edge_set {
    double x0;
    double y0;
    set<_edge> edges;
    
    //sample args => (x0, y0, -1, -1, W-1, H-1)
    _edge_set (double x00, double y00, double xlow, double ylow, double xhigh, double yhigh) {
        x0 = x00; y0 = y00;
        edges.insert(_edge(x0, y0, xlow,  ylow,  xhigh, ylow));
        edges.insert(_edge(x0, y0, xhigh, ylow,  xhigh, yhigh));
        edges.insert(_edge(x0, y0, xhigh, yhigh, xlow,  yhigh));
        edges.insert(_edge(x0, y0, xlow,  yhigh, xlow,  ylow));
    }
//    void add_edge(const _edge a) {
//        edges.insert(_edge(x0, y0, a.x1, a.y1, a.x2, a.y2));
//    }
};

/*
 * get_around function
 * Get edges full circle from a part of edge e0.
 */
void get_around (int H, int W, string blocks[], _edge e0, vector<_edge> &edges) {
    DBG("  get_around");
    DBG3("  (e0.x1:e0.y1)",e0.x1,e0.y1);
    DBG3("  (e0.x2:e0.y2)",e0.x2,e0.y2);
    
    DBG2("  SZ(edges)",SZ(edges));
    FORI(i, SZ(edges)) {
        if (edges[i].includes(e0)) {
            DBG("  => included");
            return;
        }
    }
    
    _edge e = _edge(e0.x1, e0.y1, e0.x2, e0.y2);
    double x0 = e.x1;
    double y0 = e.y1;
    double dx = e.x2 - e.x1;
    double dy = e.y2 - e.y1;
    
    while (e.x2 != x0 or e.y2 != y0) {
        double ddx = -dy;
        double ddy = dx;
        double x3 = e.x2 + 0.5 + 0.5*(dx+dy);
        double y3 = e.y2 + 0.5 + 0.5*(-dx+dy);
        DBG("----");
        DBG3("    (dx    :dy    )",dx,dy);
        DBG3("    (ddx   :ddy   )",ddx,ddy);
        DBG3("    (x3    :y3    )",x3,y3);
        DBG3("    (x3+ddx:y3+ddy)",x3+ddx,y3+ddy);
        
        if (x3 < 0 or W <= x3 or y3 < 0 or H <= y3 or
            x3+ddx < 0 or W <= x3+ddx or y3+ddy < 0 or H <= y3+ddy)
        {
            cout <<"ERROR" <<endl;
            return;
        }
        
        if (blocks[(int)(x3)][(int)(y3)] == '#' and
            blocks[(int)(x3+ddx)][(int)(y3+ddy)] != '#')
        {
            DBG("    ->go straight");
            e.x2 += dx; e.y2 += dy;
        }
        else {
            edges.PB(e);
            DBG("    ->corner");
            DBG3("     add edge (x1,y1)",e.x1,e.y1);
            DBG3("              (x2,y2)",e.x2,e.y2);
            
            if (blocks[(int)(x3)][(int)(x3)] == '#') {
                dx = ddx; dy = ddy;
                DBG("     ->turn right");
            }
            else {
                dx = -ddx; dy = -ddy;
                DBG("     ->turn left");
            }
            e.x1 = e.x2; e.y1 = e.y2;
            e.x2 += dx; e.y2 += dy;
        }
    }
    DBG("----end");
    
    //fix first edge's start point
    if (e.parallel(e0)) {
        FORI(i, SZ(edges)) {
            if (edges[i].x1 == e0.x1 and
                edges[i].y1 == e0.y1 and
                edges[i].parallel(e0))
            {
                edges[i].x1 = e.x1;
                edges[i].y1 = e.y1;
                DBG3("  fix first edge (x1,y1)",e.x1,edges[i].y1);
                DBG3("                 (x2,y2)",e.x2,edges[i].y2);
                return;
            }
        }
    }
    
    edges.PB(e);
    DBG3("  add edge (x1,y1)",e.x1,e.y1);
    DBG3("           (x2,y2)",e.x2,e.y2);
    return;
};

/*
 * main funtion
 */
int main() {
    int T;
    cin >>T;
    cin.ignore();
    
    for(int t=1; t<=T; t++) {
        
        //input
        int H, W, D;
        cin >>H >>W >>D;
        string blocks[H];
        FORI(i, H) cin >>blocks[i];
        DBG2("H", H);
        DBG2("W", W);
        DBG2("D", D);
        
        //initialize
        double xme, yme;
        vector<_edge> edges;
        FORI(y, H) FORI(x, W) {
            DBG3(" (x:y)",x, y);
            
            if (blocks[y][x] == 'X') {
                xme = x + 0.5;
                yme = y + 0.5;
                DBG3(" (xme:yme)",xme,yme);
            }
            
            if (x == W-1) continue;
            if (y == H-1) continue;
            DBG3(" blocks",blocks[y][x],blocks[y][x+1]);
            DBG3("       ",blocks[y+1][x],blocks[y+1][x+1]);
            
            _edge e(x, y, 0, 0);
            if (blocks[y][x]   == '#' and blocks[y][x+1]   != '#') {
                e.x2 = x; e.y2 = y-1;
                get_around(H, W, blocks, e, edges);
            }
            if (blocks[y][x+1] == '#' and blocks[y+1][x+1] != '#') {
                e.x2 = x+1; e.y2 = y;
                get_around(H, W, blocks, e, edges);
            }
            if (blocks[y+1][x+1] == '#' and blocks[y+1][x] != '#') {
                e.x2 = x; e.y2 = y+1;
                get_around(H, W, blocks, e, edges);
            }
            if (blocks[y+1][x]   == '#' and blocks[y][x]   != '#') {
                e.x2 = x-1; e.y2 = y;
                get_around(H, W, blocks, e, edges);
            }
        }
        
        set<pair<double, double> > me;
        me.insert(pair<double, double> (0, 0));
        _edge_set edge_set = _edge_set(xme, yme, -1, -1, W-1, H-1);
        
//        //start loop
//        set<_point>::iterator it = corners.begin();
//        while (it != corners.end()) {
//            
//        }
        
        int ret = 0;
        cout <<"Case #" <<t <<": " <<ret <<endl;
    }
    
    return 0;
}

