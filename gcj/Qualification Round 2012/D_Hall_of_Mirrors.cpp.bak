#include <stdio.h>
#include <time.h>
#include <vector>
#include <list>
#include <set>
#include <string>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <sstream>
#include <queue>
#include <map>
#include <iomanip>
#include <cmath>
#include <stack>
#include <numeric>
#include <iterator>
#include <cstdio>
#include <cstdlib>
#include <climits>
#include <cfloat>
#include <utility>
#include <memory>
#include <functional>
#include <complex>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef vector<LL> VL;

#define FORE(it, c, T) for(T::iterator it = c.begin(); it != c.end(); it++)
#define FORI(i, n) for(int i = 0; i < (n); i++)
#define FORIS(i, s, n) for(int i = (s); i < (n); i++)
#define CLEAR(a) memset(a, 0, sizeof(a))
#define SORT(a) sort(a.begin(), a.end())
#define REVERSE(a) reverse(a.begin(), a.end())
#define PB(n) push_back(n)
#define SZ(a) int((a).size())
#define IPOW(a,b) ((long long) pow((double)(a),(double)(b)))
#define PI M_PI
#define EPS 1e-13
#define INF 0x7f7f7f7f

#define DEBUG 1
#define DBG(a) if (DEBUG) cout <<"DEBUG::: " <<a <<endl;
#define DBG2(a, b) if (DEBUG) cout <<"DEBUG::: " <<a <<"=" <<b <<endl;

double xme = 0.;
double yme = 0.;

inline double dist_of(double x1, double y1, double x2, double y2) {
    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
}

inline double dist_of(double x1, double y1) {
    return dist_of(x1, y1, xme, yme);
}

inline double angle_of(double x1, double y1, double x2, double y2) {
    return atan2(y1 - y2, x1 - x2);
}

inline double angle_of(double x1, double y1) {
    return angle_of(x1, y1, xme, yme);
}

//struct _point {
//    double x;
//    double y;
//    double angle;
//    _point (double x0, double y0, double angle0) {
//        x = x0; y = y0; angle = angle0;
//    }
//    inline bool operator < (const _point a) const {
//        return angle < a.angle;
//    }
//};

struct _edge {
    double x1;
    double y1;
    double x2;
    double y2;
    _edge (double x10, double y10, double x20, double y20) {
        x1 = x10; y1 = y10; x2 = x20; y2 = y20;
    }
};

int main() {
    int T;
    cin >>T;
    cin.ignore();
    
    for(int t=1; t<=T; t++) {
        
        //input
        int H, W, D;
        cin >>H >>W >>D;
        string blocks[H];
        FORI(i, H) cin >>blocks[i];
        //set<_point> corners;
        VD x_corner, y_corner;
        vector<_edge> edges;
        
//        //2-dimensional vector
//        vector<vector<bool> > ru(H, vector<bool>(W, false));
//        vector<vector<bool> > rd(H, vector<bool>(W, false));
//        vector<vector<bool> > lu(H, vector<bool>(W, false));
//        vector<vector<bool> > ld(H, vector<bool>(W, false));
        
        //initialize
        FORI(y, H) FORI(x, W) {
            if (blocks[y][x] == 'X') {
                xme = x + 0.5;
                yme = y + 0.5;
                break;
            }
        }
        FORI(y, H) FORI(x, W) {
            if (x == W-1) continue;
            if (y == H-1) continue;
            
            int num = 0;
            if (blocks[y][x]     == '#') num++;
            if (blocks[y][x+1]   == '#') num++;
            if (blocks[y+1][x]   == '#') num++;
            if (blocks[y+1][x+1] == '#') num++;
            if (num % 2 == 1) {
//                corners.insert(_point(x, y, angle_of(x, y)));
                x_corner.PB(x); y_corner.PB(y);
            }
            
            if (blocks[y][x] == '#' and blocks[y][x+1] != '#') {
                edges.PB(_edge(x, y, x, y-1));
            }
            else if (blocks[y][x] != '#' and blocks[y][x+1] == '#') {
                edges.PB(_edge(x, y-1, x, y));
            }
            if (blocks[y][x] == '#' and blocks[y+1][x] != '#') {
                edges.PB(_edge(x, y, x-1, y));
            }
            else if (blocks[y][x] != '#' and blocks[y+1][x] == '#') {
                edges.PB(_edge(x-1, y, x, y));
            }
        }
        
        //start loop
        set<_point>::iterator it = corners.begin();
        while (it != corners.end()) {
            
        }
        
        int ret = 0;
        cout <<"Case #" <<t <<": " <<ret <<endl;
    }
    
    return 0;
}
